{"ast":null,"code":"const openUpperRowTiles=(selectedIndex,updatedOpenedCellList,generatedGrid,mineSize)=>{const updatedIndex=selectedIndex-mineSize;if(!updatedOpenedCellList[updatedIndex]){updatedOpenedCellList[updatedIndex]=1;generatedGrid[updatedIndex]===0&&(updatedOpenedCellList=openSurroundingCells(updatedIndex,updatedOpenedCellList,generatedGrid,mineSize));}if(updatedIndex%mineSize!==0&&!updatedOpenedCellList[updatedIndex-1]){updatedOpenedCellList[updatedIndex-1]=1;generatedGrid[updatedIndex-1]===0&&(updatedOpenedCellList=openSurroundingCells(updatedIndex-1,updatedOpenedCellList,generatedGrid,mineSize));}if((updatedIndex+1)%mineSize!==0&&!updatedOpenedCellList[updatedIndex+1]){updatedOpenedCellList[updatedIndex+1]=1;generatedGrid[updatedIndex+1]===0&&(updatedOpenedCellList=openSurroundingCells(updatedIndex+1,updatedOpenedCellList,generatedGrid,mineSize));}return updatedOpenedCellList;};const openLowerRowTiles=(selectedIndex,updatedOpenedCellList,generatedGrid,mineSize)=>{const updatedIndex=selectedIndex+mineSize;if(!updatedOpenedCellList[updatedIndex]){updatedOpenedCellList[updatedIndex]=1;generatedGrid[updatedIndex]===0&&(updatedOpenedCellList=openSurroundingCells(updatedIndex,updatedOpenedCellList,generatedGrid,mineSize));}if(updatedIndex%mineSize!==0&&!updatedOpenedCellList[updatedIndex-1]){updatedOpenedCellList[updatedIndex-1]=1;generatedGrid[updatedIndex-1]===0&&(updatedOpenedCellList=openSurroundingCells(updatedIndex-1,updatedOpenedCellList,generatedGrid,mineSize));}if((updatedIndex+1)%mineSize!==0&&!updatedOpenedCellList[updatedIndex+1]){updatedOpenedCellList[updatedIndex+1]=1;generatedGrid[updatedIndex+1]===0&&(updatedOpenedCellList=openSurroundingCells(updatedIndex+1,updatedOpenedCellList,generatedGrid,mineSize));}return updatedOpenedCellList;};export const openSurroundingCells=(selectedIndex,updatedOpenedCellList,generatedGrid,mineSize)=>{updatedOpenedCellList[selectedIndex]=1;const isFirstRow=selectedIndex<mineSize;const isLastRow=selectedIndex>=mineSize*(mineSize-1);// Open tiles below the selected tile\n!isLastRow&&(updatedOpenedCellList=openLowerRowTiles(selectedIndex,updatedOpenedCellList,generatedGrid,mineSize));// Open tiles above the selected tile\n!isFirstRow&&(updatedOpenedCellList=openUpperRowTiles(selectedIndex,updatedOpenedCellList,generatedGrid,mineSize));if(selectedIndex%mineSize!==0&&!updatedOpenedCellList[selectedIndex-1]){// Open tiles to the left of selected tile\nupdatedOpenedCellList[selectedIndex-1]=1;generatedGrid[selectedIndex-1]===0&&(updatedOpenedCellList=openSurroundingCells(selectedIndex-1,updatedOpenedCellList,generatedGrid,mineSize));}if((selectedIndex+1)%mineSize!==0&&!updatedOpenedCellList[selectedIndex+1]){// Open tiles to the right of selected tile\nupdatedOpenedCellList[selectedIndex+1]=1;generatedGrid[selectedIndex+1]===0&&(updatedOpenedCellList=openSurroundingCells(selectedIndex+1,updatedOpenedCellList,generatedGrid,mineSize));}return updatedOpenedCellList;};export const matchAllOpenedTiles=(openedCellsList,generatedGrid)=>{let anyNonMineTilesUnopened=false;openedCellsList.forEach((openedCell,index)=>{if(openedCell===0&&generatedGrid[index]>=0){// Unopened Tile, Tile does not have a mine\nanyNonMineTilesUnopened=true;}else if(openedCell===-1&&generatedGrid[index]>=0){// Flagged Tile, Tile does not have a mine\nanyNonMineTilesUnopened=true;}else if(openedCell===1&&generatedGrid[index]===-1){// Opened Tile, Tile has a mine\nanyNonMineTilesUnopened=true;}});return!anyNonMineTilesUnopened;};","map":{"version":3,"names":["openUpperRowTiles","selectedIndex","updatedOpenedCellList","generatedGrid","mineSize","updatedIndex","openSurroundingCells","openLowerRowTiles","isFirstRow","isLastRow","matchAllOpenedTiles","openedCellsList","anyNonMineTilesUnopened","forEach","openedCell","index"],"sources":["/Users/anubhavkhanna/Desktop/Code Repos/MineMaster/src/utils/Utilities.ts"],"sourcesContent":["const openUpperRowTiles = (selectedIndex: number, updatedOpenedCellList: Array<number>, generatedGrid: Array<number>, mineSize: number) => {\n  const updatedIndex = selectedIndex-mineSize;\n  if(!updatedOpenedCellList[updatedIndex]) {\n    updatedOpenedCellList[updatedIndex] = 1;\n    (generatedGrid[updatedIndex] === 0) && (updatedOpenedCellList = openSurroundingCells(updatedIndex, updatedOpenedCellList, generatedGrid, mineSize));\n  }\n  if ((updatedIndex%mineSize) !== 0 && !updatedOpenedCellList[updatedIndex - 1]) {\n    updatedOpenedCellList[updatedIndex - 1] = 1;\n    (generatedGrid[updatedIndex - 1] === 0) && (updatedOpenedCellList = openSurroundingCells(updatedIndex - 1, updatedOpenedCellList, generatedGrid, mineSize));\n  }\n  if (((updatedIndex+1)%mineSize) !== 0 && !updatedOpenedCellList[updatedIndex + 1]) {\n    updatedOpenedCellList[updatedIndex + 1] = 1;\n    (generatedGrid[updatedIndex + 1] === 0) && (updatedOpenedCellList = openSurroundingCells(updatedIndex + 1, updatedOpenedCellList, generatedGrid, mineSize));\n  }\n  return updatedOpenedCellList;\n}\n\nconst openLowerRowTiles = (selectedIndex: number, updatedOpenedCellList: Array<number>, generatedGrid: Array<number>, mineSize: number) => {\n  const updatedIndex = selectedIndex+mineSize;\n  if(!updatedOpenedCellList[updatedIndex]) {\n    updatedOpenedCellList[updatedIndex] = 1;\n    (generatedGrid[updatedIndex] === 0) && (updatedOpenedCellList = openSurroundingCells(updatedIndex, updatedOpenedCellList, generatedGrid, mineSize));\n  }\n  if ((updatedIndex%mineSize) !== 0 && !updatedOpenedCellList[updatedIndex - 1]) {\n    updatedOpenedCellList[updatedIndex - 1] = 1;\n    (generatedGrid[updatedIndex - 1] === 0) && (updatedOpenedCellList = openSurroundingCells(updatedIndex - 1, updatedOpenedCellList, generatedGrid, mineSize));\n  }\n  if(((updatedIndex+1)%mineSize) !== 0 && !updatedOpenedCellList[updatedIndex + 1]) {\n    updatedOpenedCellList[updatedIndex + 1] = 1;\n    (generatedGrid[updatedIndex + 1] === 0) && (updatedOpenedCellList = openSurroundingCells(updatedIndex + 1, updatedOpenedCellList, generatedGrid, mineSize));\n  }\n  return updatedOpenedCellList;\n}\n\nexport const openSurroundingCells = (selectedIndex: number, updatedOpenedCellList: Array<number>, generatedGrid: Array<number>, mineSize: number) => {\n  updatedOpenedCellList[selectedIndex] = 1;\n    const isFirstRow = selectedIndex < (mineSize);\n    const isLastRow = selectedIndex >= (mineSize*(mineSize-1));\n\n    // Open tiles below the selected tile\n    !isLastRow && (updatedOpenedCellList = openLowerRowTiles(selectedIndex, updatedOpenedCellList, generatedGrid, mineSize));\n\n    // Open tiles above the selected tile\n    !isFirstRow && (updatedOpenedCellList = openUpperRowTiles(selectedIndex, updatedOpenedCellList, generatedGrid, mineSize));\n\n    if((selectedIndex%mineSize) !== 0 && !updatedOpenedCellList[selectedIndex - 1]) {\n      // Open tiles to the left of selected tile\n      updatedOpenedCellList[selectedIndex - 1] = 1;\n      (generatedGrid[selectedIndex - 1] === 0) && (updatedOpenedCellList = openSurroundingCells(selectedIndex - 1, updatedOpenedCellList, generatedGrid, mineSize));\n    }\n    if(((selectedIndex+1)%mineSize) !== 0 && !updatedOpenedCellList[selectedIndex + 1] ) {\n      // Open tiles to the right of selected tile\n      updatedOpenedCellList[selectedIndex + 1] = 1;\n      (generatedGrid[selectedIndex + 1] === 0) && (updatedOpenedCellList = openSurroundingCells(selectedIndex + 1, updatedOpenedCellList, generatedGrid, mineSize));\n    }\n    return updatedOpenedCellList;\n}\n\nexport const matchAllOpenedTiles = (openedCellsList: Array<number>, generatedGrid: Array<number>) => {\n  let anyNonMineTilesUnopened = false;\n  openedCellsList.forEach((openedCell, index) => {\n    if (openedCell === 0 && generatedGrid[index] >= 0 ) {\n      // Unopened Tile, Tile does not have a mine\n      anyNonMineTilesUnopened = true;\n    } else if (openedCell === -1 && generatedGrid[index] >= 0) {\n      // Flagged Tile, Tile does not have a mine\n      anyNonMineTilesUnopened = true;\n    } else if (openedCell === 1 && generatedGrid[index] === -1) {\n      // Opened Tile, Tile has a mine\n      anyNonMineTilesUnopened = true;\n    }\n  });\n  return !anyNonMineTilesUnopened;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}